var documenterSearchIndex = {"docs":
[{"location":"#Libwebsockets.jl","page":"Home","title":"Libwebsockets.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Libwebsockets is a Julia wrapper for the libwebsockets library, providing verstile tooling for setting up WebSocket and HTTP clients and servers, managing SSL connections, and handling data efficiently in a variety of applications.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install Libwebsockets, simply use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add Libwebsockets","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"With Libwebsockets, you can quickly connect to a WebSocket stream in Julia. In just a few lines, set up a client, handle incoming events, and process data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Libwebsockets\n\nmutable struct UserData\n    callback::Function\nend\n\nfunction ws_callback(wsi::Ptr{Cvoid}, reason::Cint, user::Ptr{Cvoid}, data::Ptr{Cvoid}, len::Csize_t)\n    if reason == LWS_CALLBACK_CLIENT_RECEIVE && data != C_NULL\n        ctx = lws_get_context(wsi)\n        user_ctx = unsafe_pointer_to_objref(lws_context_user(ctx))\n        user_ctx.callback(unsafe_wrap(Vector{UInt8}, Ptr{UInt8}(data), len))\n    end\n    return lws_callback_http_dummy(wsi, reason, user, data, len)\nend\n\nfunction ws_open(callback::Function, addr::String, port::Int, path::String)\n    callback_ptr = @cfunction(ws_callback, Cint, (Ptr{Cvoid}, Cint, Ptr{Cvoid}, Ptr{Cvoid}, Csize_t))\n    protocols = [\n        LwsProtocols(pointer(\"ws\"), callback_ptr, 0, 0, 0, C_NULL, 0),\n        LwsProtocols(C_NULL, C_NULL, 0, 0, 0, C_NULL, 0)\n    ]\n    user = UserData(callback)\n\n    ctx_info = LwsContextCreationInfo()\n    ctx_info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT\n    ctx_info.port = CONTEXT_PORT_NO_LISTEN\n    ctx_info.user = Base.unsafe_convert(Ptr{UserData}, Ref(user))\n    ctx_info.protocols = pointer(protocols)\n    ws_ctx = lws_create_context(Ref(ctx_info))\n\n    conn_info = LwsClientConnectInfo()\n    conn_info.context = ws_ctx\n    conn_info.port = port\n    conn_info.address = pointer(addr)\n    conn_info.path = pointer(path)\n    conn_info.host = conn_info.address\n    conn_info.ssl_connection = LCCSCF_USE_SSL | LCCSCF_ALLOW_SELFSIGNED\n    lws_client_connect_via_info(Ref(conn_info))\n\n    while true\n        lws_service(ws_ctx, 0)\n    end\nend\n\nws_open(\"stream.binance.com\", 9443, \"/stream?streams=adausdt@depth5@100ms\") do message\n    println(\"Received message: \", String(message))\nend","category":"page"},{"location":"#Useful-Links","page":"Home","title":"Useful Links","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Libwebsockets – detailed library docs.\nlibwebsockets_jll – latest wrapper version.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions to Libwebsockets are welcome! If you encounter a bug, have a feature request, or would like to contribute code, please open an issue or a pull request on GitHub.","category":"page"},{"location":"pages/manual/#WebSocket-Client-Example","page":"Manual","title":"WebSocket Client Example","text":"","category":"section"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Here we demonstrate how to create a WebSocket client using Libwebsockets in Julia. The client connects to data stream and receives updates for a specified trading pair. A callback function processes each incoming message, making it easy to handle data as it arrives. The client is configured with SSL support for secure communication, and you can customize the handler function to suit your data-processing needs.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Firstly we need to define User Data Structure:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"UserData is a struct holding a function callback, which will process the incoming WebSocket messages.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"using Libwebsockets\n\nmutable struct UserData\n    callback::Function\nend","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Then we define WebSocket Callback Function:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"ws_callback is a function that gets triggered on various WebSocket events and calls the user-defined function callback on the message data.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"function ws_callback(wsi::Ptr{Cvoid}, reason::Cint, user::Ptr{Cvoid}, data::Ptr{Cvoid}, len::Csize_t)\n    if reason == LWS_CALLBACK_CLIENT_RECEIVE && data != C_NULL\n        ctx = lws_get_context(wsi)\n        user_ctx = unsafe_pointer_to_objref(lws_context_user(ctx))\n        user_ctx.callback(unsafe_wrap(Vector{UInt8}, Ptr{UInt8}(data), len))\n    end\n    return lws_callback_http_dummy(wsi, reason, user, data, len)\nend","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Now we can define main ws_open function to open and initialize WebSocket connection. It has three main steps:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Setup WebSocket Protocol and Callback:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"It defines a WebSocket callback function ws_callback that handles incoming WebSocket events. A protocol structure is created to specify which function should be used for WebSocket events. User data is also set up, containing the callback function the user wants to use to process incoming messages.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Configure and Create WebSocket Context:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"LwsContextCreationInfo is initialized with options for SSL and non-listening mode (indicating this is a client). This configuration is passed to lws_create_context, which creates the WebSocket context needed to manage the connection.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Establish the WebSocket Connection and Event Loop:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"LwsClientConnectInfo is set up with server details like the address, port, path, user, and SSL options, and the connection is initiated using lws_client_connect_via_info. The function then enters an infinite loop, continuously calling lws_service to handle WebSocket events (such as receiving messages) and process them via the user-defined callback.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"function ws_open(callback::Function, addr::String, port::Int, path::String)\n    callback_ptr = @cfunction(ws_callback, Cint, (Ptr{Cvoid}, Cint, Ptr{Cvoid}, Ptr{Cvoid}, Csize_t))\n    protocols = [\n        LwsProtocols(pointer(\"ws\"), callback_ptr, 0, 0, 0, C_NULL, 0),\n        LwsProtocols(C_NULL, C_NULL, 0, 0, 0, C_NULL, 0)\n    ]\n    user = UserData(callback)\n\n    ctx_info = LwsContextCreationInfo()\n    ctx_info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT\n    ctx_info.port = CONTEXT_PORT_NO_LISTEN\n    ctx_info.user = Base.unsafe_convert(Ptr{UserData}, Ref(user))\n    ctx_info.protocols = pointer(protocols)\n    ws_ctx = lws_create_context(Ref(ctx_info))\n\n    conn_info = LwsClientConnectInfo()\n    conn_info.context = ws_ctx\n    conn_info.port = port\n    conn_info.address = pointer(addr)\n    conn_info.path = pointer(path)\n    conn_info.host = conn_info.address\n    conn_info.ssl_connection = LCCSCF_USE_SSL | LCCSCF_ALLOW_SELFSIGNED\n    lws_client_connect_via_info(Ref(conn_info))\n\n    while true\n        lws_service(ws_ctx, 0)\n    end\nend","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"User-defined Callback:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Finally ws_open is called with a user-defined callback function that simply prints any received messages.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"ws_open(\"stream.binance.com\", 9443, \"/stream?streams=adausdt@depth5@100ms\") do message\n    println(\"Received message: \", String(message))\nend","category":"page"}]
}
